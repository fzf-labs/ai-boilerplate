// Code generated by gen/repo. DO NOT EDIT.
// Code generated by gen/repo. DO NOT EDIT.
// Code generated by gen/repo. DO NOT EDIT.

package ai_boilerplate_repo

import (
	"context"
	"errors"

	"github.com/fzf-labs/ai-boilerplate-backend/internal/data/gorm/ai_boilerplate_dao"
	"github.com/fzf-labs/ai-boilerplate-backend/internal/data/gorm/ai_boilerplate_model"
	"github.com/fzf-labs/godb/orm/condition"
	"github.com/fzf-labs/godb/orm/dbcache"
	"github.com/fzf-labs/godb/orm/encoding"
	"github.com/fzf-labs/godb/orm/gen/config"
	"github.com/jinzhu/copier"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

var _ IUserNotificationSettingRepo = (*UserNotificationSettingRepo)(nil)

var (
	CacheUserNotificationSettingByConditionPrefix         = "DBCache:ai_boilerplate:UserNotificationSettingByCondition"
	CacheUserNotificationSettingUnscopedByConditionPrefix = "DBCache:ai_boilerplate:UserNotificationSettingUnscopedByCondition"
)

type (
	IUserNotificationSettingRepo interface {
		// NewData 实例化
		NewData() *ai_boilerplate_model.UserNotificationSetting
		// DeepCopy 深拷贝
		DeepCopy(data *ai_boilerplate_model.UserNotificationSetting) *ai_boilerplate_model.UserNotificationSetting
		// CreateOne 创建一条数据
		CreateOne(ctx context.Context, data *ai_boilerplate_model.UserNotificationSetting) error
		// CreateOneByTx 创建一条数据(事务)
		CreateOneByTx(ctx context.Context, tx *ai_boilerplate_dao.Query, data *ai_boilerplate_model.UserNotificationSetting) error
		// CreateBatch 批量创建数据
		CreateBatch(ctx context.Context, data []*ai_boilerplate_model.UserNotificationSetting, batchSize int) error
		// CreateBatchByTx 批量创建数据(事务)
		CreateBatchByTx(ctx context.Context, tx *ai_boilerplate_dao.Query, data []*ai_boilerplate_model.UserNotificationSetting, batchSize int) error
		// UpsertOneByFields 根据fields字段Upsert一条数据
		UpsertOneByFields(ctx context.Context, data *ai_boilerplate_model.UserNotificationSetting, fields []string) error
		// UpsertOneByFieldsTx 根据fields字段Upsert一条数据(事务)
		UpsertOneByFieldsTx(ctx context.Context, tx *ai_boilerplate_dao.Query, data *ai_boilerplate_model.UserNotificationSetting, fields []string) error
		// FindMultiByCondition 自定义查询数据(通用)
		FindMultiByCondition(ctx context.Context, conditionReq *condition.Req) ([]*ai_boilerplate_model.UserNotificationSetting, *condition.Reply, error)
		// FindMultiUnscopedByCondition 自定义查询数据(通用)（包括软删除）
		FindMultiUnscopedByCondition(ctx context.Context, conditionReq *condition.Req) ([]*ai_boilerplate_model.UserNotificationSetting, *condition.Reply, error)
		// FindMultiCacheByCondition 自定义查询数据(通用),并设置缓存
		FindMultiCacheByCondition(ctx context.Context, conditionReq *condition.Req) ([]*ai_boilerplate_model.UserNotificationSetting, *condition.Reply, error)
		// FindMultiUnscopedCacheByCondition 自定义查询数据(通用)（包括软删除）,并设置缓存
		FindMultiUnscopedCacheByCondition(ctx context.Context, conditionReq *condition.Req) ([]*ai_boilerplate_model.UserNotificationSetting, *condition.Reply, error)
	}
	UserNotificationSettingRepo struct {
		db       *gorm.DB
		cache    dbcache.IDBCache
		encoding encoding.API
	}
)

func NewUserNotificationSettingRepo(cfg *config.Repo) *UserNotificationSettingRepo {
	return &UserNotificationSettingRepo{
		db:       cfg.DB,
		cache:    cfg.Cache,
		encoding: cfg.Encoding,
	}
}

// NewData 实例化
func (u *UserNotificationSettingRepo) NewData() *ai_boilerplate_model.UserNotificationSetting {
	return &ai_boilerplate_model.UserNotificationSetting{}
}

// DeepCopy 深拷贝
func (u *UserNotificationSettingRepo) DeepCopy(data *ai_boilerplate_model.UserNotificationSetting) *ai_boilerplate_model.UserNotificationSetting {
	newData := new(ai_boilerplate_model.UserNotificationSetting)
	_ = copier.CopyWithOption(newData, data, copier.Option{DeepCopy: true})
	return newData
}

// CreateOne 创建一条数据
func (u *UserNotificationSettingRepo) CreateOne(ctx context.Context, data *ai_boilerplate_model.UserNotificationSetting) error {
	dao := ai_boilerplate_dao.Use(u.db).UserNotificationSetting
	err := dao.WithContext(ctx).Create(data)
	if err != nil {
		return err
	}
	return nil
}

// CreateOneByTx 创建一条数据(事务)
func (u *UserNotificationSettingRepo) CreateOneByTx(ctx context.Context, tx *ai_boilerplate_dao.Query, data *ai_boilerplate_model.UserNotificationSetting) error {
	dao := tx.UserNotificationSetting
	err := dao.WithContext(ctx).Create(data)
	if err != nil {
		return err
	}
	return nil
}

// CreateBatch 批量创建数据
func (u *UserNotificationSettingRepo) CreateBatch(ctx context.Context, data []*ai_boilerplate_model.UserNotificationSetting, batchSize int) error {
	dao := ai_boilerplate_dao.Use(u.db).UserNotificationSetting
	err := dao.WithContext(ctx).CreateInBatches(data, batchSize)
	if err != nil {
		return err
	}
	return nil
}

// CreateBatchByTx 批量创建数据(事务)
func (u *UserNotificationSettingRepo) CreateBatchByTx(ctx context.Context, tx *ai_boilerplate_dao.Query, data []*ai_boilerplate_model.UserNotificationSetting, batchSize int) error {
	dao := tx.UserNotificationSetting
	err := dao.WithContext(ctx).CreateInBatches(data, batchSize)
	if err != nil {
		return err
	}
	return nil
}

// UpsertOneByFields 根据fields字段Upsert一条数据
func (u *UserNotificationSettingRepo) UpsertOneByFields(ctx context.Context, data *ai_boilerplate_model.UserNotificationSetting, fields []string) error {
	if len(fields) == 0 {
		return errors.New("UpsertOneByFields fields is empty")
	}
	columns := make([]clause.Column, 0)
	for _, item := range fields {
		columns = append(columns, clause.Column{Name: item})
	}
	dao := ai_boilerplate_dao.Use(u.db).UserNotificationSetting
	err := dao.WithContext(ctx).Clauses(clause.OnConflict{
		Columns:   columns,
		UpdateAll: true,
	}).Create(data)
	if err != nil {
		return err
	}
	return nil
}

// UpsertOneByFieldsTx 根据fields字段Upsert一条数据(事务)
func (u *UserNotificationSettingRepo) UpsertOneByFieldsTx(ctx context.Context, tx *ai_boilerplate_dao.Query, data *ai_boilerplate_model.UserNotificationSetting, fields []string) error {
	if len(fields) == 0 {
		return errors.New("UpsertOneByFieldsTx fields is empty")
	}
	columns := make([]clause.Column, 0)
	for _, item := range fields {
		columns = append(columns, clause.Column{Name: item})
	}
	dao := tx.UserNotificationSetting
	err := dao.WithContext(ctx).Clauses(clause.OnConflict{
		Columns:   columns,
		UpdateAll: true,
	}).Create(data)
	if err != nil {
		return err
	}
	return nil
}

// FindMultiByCondition 自定义查询数据(通用)
// 非万能查询方法,请评估后谨慎使用
func (u *UserNotificationSettingRepo) FindMultiByCondition(ctx context.Context, conditionReq *condition.Req) ([]*ai_boilerplate_model.UserNotificationSetting, *condition.Reply, error) {
	result := make([]*ai_boilerplate_model.UserNotificationSetting, 0)
	conditionReply := &condition.Reply{}
	var total int64
	whereExpressions, orderExpressions, err := conditionReq.ConvertToGormExpression(ai_boilerplate_model.UserNotificationSetting{})
	if err != nil {
		return result, conditionReply, err
	}
	if conditionReq.Page != 0 && conditionReq.PageSize != 0 {
		err = u.db.WithContext(ctx).Model(&ai_boilerplate_model.UserNotificationSetting{}).Clauses(whereExpressions...).Count(&total).Error
		if err != nil {
			return result, conditionReply, err
		}
		if total == 0 {
			return result, conditionReply, nil
		}
		conditionReply, err = conditionReq.ConvertToPage(int32(total))
		if err != nil {
			return result, conditionReply, err
		}
		query := u.db.WithContext(ctx).Model(&ai_boilerplate_model.UserNotificationSetting{}).Clauses(whereExpressions...).Clauses(orderExpressions...)
		if conditionReply.Page != 0 && conditionReply.PageSize != 0 {
			query = query.Offset(int((conditionReply.Page - 1) * conditionReply.PageSize))
			query = query.Limit(int(conditionReply.PageSize))
		}
		err = query.Find(&result).Error
		if err != nil {
			return result, conditionReply, err
		}
	} else {
		err = u.db.WithContext(ctx).Model(&ai_boilerplate_model.UserNotificationSetting{}).Clauses(whereExpressions...).Clauses(orderExpressions...).Find(&result).Error
		if err != nil {
			return result, conditionReply, err
		}
		conditionReply.Total = int32(len(result))
	}
	return result, conditionReply, err
}

// FindMultiUnscopedByCondition 自定义查询数据(通用)（包括软删除）
// 非万能查询方法,请评估后谨慎使用
func (u *UserNotificationSettingRepo) FindMultiUnscopedByCondition(ctx context.Context, conditionReq *condition.Req) ([]*ai_boilerplate_model.UserNotificationSetting, *condition.Reply, error) {
	result := make([]*ai_boilerplate_model.UserNotificationSetting, 0)
	conditionReply := &condition.Reply{}
	var total int64
	whereExpressions, orderExpressions, err := conditionReq.ConvertToGormExpression(ai_boilerplate_model.UserNotificationSetting{})
	if err != nil {
		return result, conditionReply, err
	}
	if conditionReq.Page != 0 && conditionReq.PageSize != 0 {
		err = u.db.WithContext(ctx).Model(&ai_boilerplate_model.UserNotificationSetting{}).Unscoped().Clauses(whereExpressions...).Count(&total).Error
		if err != nil {
			return result, conditionReply, err
		}
		if total == 0 {
			return result, conditionReply, nil
		}
		conditionReply, err = conditionReq.ConvertToPage(int32(total))
		if err != nil {
			return result, conditionReply, err
		}
		query := u.db.WithContext(ctx).Model(&ai_boilerplate_model.UserNotificationSetting{}).Unscoped().Clauses(whereExpressions...).Clauses(orderExpressions...)
		if conditionReply.Page != 0 && conditionReply.PageSize != 0 {
			query = query.Offset(int((conditionReply.Page - 1) * conditionReply.PageSize))
			query = query.Limit(int(conditionReply.PageSize))
		}
		err = query.Find(&result).Error
		if err != nil {
			return result, conditionReply, err
		}
	} else {
		err = u.db.WithContext(ctx).Model(&ai_boilerplate_model.UserNotificationSetting{}).Unscoped().Clauses(whereExpressions...).Clauses(orderExpressions...).Find(&result).Error
		if err != nil {
			return result, conditionReply, err
		}
		conditionReply.Total = int32(len(result))
	}
	return result, conditionReply, err
}

// FindMultiCacheByCondition 自定义查询数据(通用),并设置缓存
// 非万能查询方法,缓存命中率低,请评估后谨慎使用
func (u *UserNotificationSettingRepo) FindMultiCacheByCondition(ctx context.Context, conditionReq *condition.Req) ([]*ai_boilerplate_model.UserNotificationSetting, *condition.Reply, error) {
	type Tmp struct {
		Result         []*ai_boilerplate_model.UserNotificationSetting
		ConditionReply *condition.Reply
	}
	tmp := Tmp{
		Result:         make([]*ai_boilerplate_model.UserNotificationSetting, 0),
		ConditionReply: &condition.Reply{},
	}
	cacheKey := u.cache.Key(CacheUserNotificationSettingByConditionPrefix)
	cacheField := conditionReq.ConvertToCacheField()
	cacheValue, err := u.cache.FetchHash(ctx, cacheKey, cacheField, func() (string, error) {
		result, conditionReply, err := u.FindMultiByCondition(ctx, conditionReq)
		if err != nil {
			return "", err
		}
		tmp.Result = result
		tmp.ConditionReply = conditionReply
		marshal, err := u.encoding.Marshal(tmp)
		if err != nil {
			return "", err
		}
		return string(marshal), nil
	}, u.cache.TTL())
	if err != nil {
		return tmp.Result, tmp.ConditionReply, err
	}
	if cacheValue != "" {
		err = u.encoding.Unmarshal([]byte(cacheValue), &tmp)
		if err != nil {
			return tmp.Result, tmp.ConditionReply, err
		}
	}
	return tmp.Result, tmp.ConditionReply, nil
}

// FindMultiUnscopedCacheByCondition 自定义查询数据(通用)（包括软删除）,并设置缓存
// 非万能查询方法,缓存命中率低,请评估后谨慎使用
func (u *UserNotificationSettingRepo) FindMultiUnscopedCacheByCondition(ctx context.Context, conditionReq *condition.Req) ([]*ai_boilerplate_model.UserNotificationSetting, *condition.Reply, error) {
	type Tmp struct {
		Result         []*ai_boilerplate_model.UserNotificationSetting
		ConditionReply *condition.Reply
	}
	tmp := Tmp{
		Result:         make([]*ai_boilerplate_model.UserNotificationSetting, 0),
		ConditionReply: &condition.Reply{},
	}
	cacheKey := u.cache.Key(CacheUserNotificationSettingUnscopedByConditionPrefix)
	cacheField := conditionReq.ConvertToCacheField()
	cacheValue, err := u.cache.FetchHash(ctx, cacheKey, cacheField, func() (string, error) {
		result, conditionReply, err := u.FindMultiUnscopedByCondition(ctx, conditionReq)
		if err != nil {
			return "", err
		}
		tmp.Result = result
		tmp.ConditionReply = conditionReply
		marshal, err := u.encoding.Marshal(tmp)
		if err != nil {
			return "", err
		}
		return string(marshal), nil
	}, u.cache.TTL())
	if err != nil {
		return tmp.Result, tmp.ConditionReply, err
	}
	if cacheValue != "" {
		err = u.encoding.Unmarshal([]byte(cacheValue), &tmp)
		if err != nil {
			return tmp.Result, tmp.ConditionReply, err
		}
	}
	return tmp.Result, tmp.ConditionReply, nil
}
